import numpy as np
import pandas as pd

def calculate_confidence_scores(df, threshold=0.6):
    """
    This function calculates five confidence scores for multi-label classification.
    It takes a dataset where each row contains probabilities for multiple labels.

    Args:
        df (pd.DataFrame): Input dataset with label probabilities.
        threshold (float): The threshold to determine predicted labels.

    Returns:
        pd.DataFrame: Updated DataFrame with 5 new confidence score columns.
    """
    
    def compute_scores(row):
        selected_probs = [p for p in row if p >= threshold]  # Probabilities above threshold
        non_selected_probs = [p for p in row if p < threshold]  # Probabilities below threshold

        # Score 1: Product-based thresholding
        score1 = np.prod([p if p >= threshold else (1 - p) for p in row])

        # Score 2: Logarithmic Confidence Score
        score2 = sum(np.log(p) for p in selected_probs) + sum(np.log(1 - p) for p in non_selected_probs)

        # Score 3: Entropy-Based Score
        entropy_score = -sum(p * np.log(p) for p in row if p > 0)  # Avoid log(0)

        # Score 4: Weighted Mean Probability Score
        weighted_mean_score = np.mean(row)

        # Score 5: Softmax Normalized Confidence Score
        exp_probs = np.exp(row)
        softmax_probs = exp_probs / np.sum(exp_probs)
        softmax_confidence = sum(p for p, original_p in zip(softmax_probs, row) if original_p >= threshold)

        return score1, score2, entropy_score, weighted_mean_score, softmax_confidence

    # Apply the function to all rows in the dataset
    df[['Score1_Product', 'Score2_Log', 'Score3_Entropy', 'Score4_WeightedMean', 'Score5_Softmax']] = df.apply(
        compute_scores, axis=1, result_type="expand"
    )

    return df

# Example Usage
if __name__ == "__main__":
    # Example dataset (Replace with real probabilities)
    data = {
        "label1": [0.9, 0.1, 0.7, 0.5, 0.95],
        "label2": [0.8, 0.2, 0.6, 0.4, 0.85],
        "label3": [0.2, 0.9, 0.3, 0.8, 0.1],
        "label4": [0.1, 0.5, 0.7, 0.3, 0.6],
    }
    
    df = pd.DataFrame(data)
    df_with_scores = calculate_confidence_scores(df, threshold=0.6)

    print(df_with_scores)



1. Product
import numpy as np
import pandas as pd

def calculate_product_score(df, threshold=0.6):
    """
    Computes confidence score using product-based thresholding.
    """
    def product_score(row):
        score = 1.0
        for prob in row:
            if prob >= threshold:
                score *= prob
            else:
                score *= (1 - prob)
        return score
    
    df["Score_Product"] = df.apply(product_score, axis=1)
    return df


2.log
def calculate_log_score(df, threshold=0.6):
    """
    Computes confidence score using the logarithmic probability method.
    """
    def log_score(row):
        selected_probs = [p for p in row if p >= threshold]
        non_selected_probs = [p for p in row if p < threshold]
        return sum(np.log(p) for p in selected_probs) + sum(np.log(1 - p) for p in non_selected_probs)
    
    df["Score_Log"] = df.apply(log_score, axis=1)
    return df


3.entropy based
def calculate_entropy_score(df):
    """
    Computes confidence score using entropy-based uncertainty measurement.
    """
    def entropy_score(row):
        return -sum(p * np.log(p) for p in row if p > 0)  # Avoid log(0)
    
    df["Score_Entropy"] = df.apply(entropy_score, axis=1)
    return df


4. weighted mean prob

def calculate_weighted_mean_score(df, weights=None):
    """
    Computes confidence score using a weighted mean of probabilities.
    """
    if weights is None:
        weights = np.ones(df.shape[1])  # Assign equal weights if none provided
    
    def weighted_mean_score(row):
        return np.dot(weights, row) / np.sum(weights)
    
    df["Score_WeightedMean"] = df.apply(weighted_mean_score, axis=1)
    return df


5.softmax
def calculate_softmax_score(df, threshold=0.6):
    """
    Computes confidence score using softmax-normalized probabilities.
    """
    def softmax_score(row):
        exp_probs = np.exp(row)
        softmax_probs = exp_probs / np.sum(exp_probs)
        return sum(p for p, original_p in zip(softmax_probs, row) if original_p >= threshold)
    
    df["Score_Softmax"] = df.apply(softmax_score, axis=1)
    return df
